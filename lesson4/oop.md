## Три принципа ООП

ООП (объектно-ориентированное программирование) - это методология программирования, которая основывается на концепциях объектов и классов. В Python, как и в других языках программирования, ООП позволяет создавать классы, которые определяют свойства (атрибуты) и методы, которые определяют поведение объектов. В дополнение к этому, в Python есть некоторые особенности, которые делают ООП более удобным и гибким.

Классы в Python определяются с помощью ключевого слова `class`, а объекты создаются путем вызова класса, как если бы это была функция. Например, вот пример создания класса и экземпляра:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Alice", 30)
```

В этом примере мы создали класс `Person` с атрибутами `name` и `age`, а затем мы создали экземпляр класса `Person` с именем "Alice" и возрастом 30. Объект `person` теперь является экземпляром класса `Person`.



### 1. Инкапсуляция
Инкапсуляция - это один из принципов ООП, который позволяет скрыть данные и методы класса от других частей программы. Это делается для защиты данных от неправильного использования и изменения, а также для упрощения интерфейса класса.

В Python инкапсуляция реализуется с помощью соглашения о том, что атрибуты и методы, начинающиеся с одного подчеркивания (`_`), являются "защищенными" и не должны быть использованы за пределами класса или его подклассов. Атрибуты и методы, начинающиеся с двух подчеркиваний (`__`), являются "закрытыми" и не могут быть использованы за пределами класса.

Вот пример класса `Person`, который использует инкапсуляцию для защиты атрибута `age`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self._age = age

    def say_hello(self):
        print(f"Hello, my name is {self.name} and I'm {self._age} years old.")

person = Person("Alice", 30)
person.say_hello()  # выводит "Hello, my name is Alice and I'm 30 years old."
print(person._age)  # выводит 30
```

В этом примере мы определили атрибут `_age` как "защищенный", чтобы предотвратить изменение его значения за пределами класса. Метод `say_hello()` все еще может использовать его значение для вывода информации о объекте. Однако мы можем обратиться к атрибуту `_age` напрямую, используя имя объекта и имя атрибута.

Но при использовании двойного подчеркивания (`__`) для определения атрибута, Python автоматически изменит имя атрибута, чтобы его не было так просто получить или изменить за пределами класса. Например, вот пример класса `Person`, который использует закрытый атрибут `__age`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    def say_hello(self):
        print(f"Hello, my name is {self.name} and I'm {self.__age} years old.")

person = Person("Alice", 30)
person.say_hello()  # выводит "Hello, my name is Alice and I'm 30 years old."
print(person.__age)  # вызывает ошибку AttributeError
```

В этом примере мы определили атрибут `__age` как "закрытый".


Для поддержки инкапсуляции в Python часто используются методы доступа, такие как геттеры и сеттеры. Геттеры и сеттеры - это специальные методы, которые позволяют получать и изменять значение закрытого атрибута класса. Геттеры используются для чтения значения атрибута, а сеттеры - для установки нового значения.

В Python геттеры и сеттеры обычно определяются с помощью свойств (property). Свойства позволяют определить методы, которые будут вызываться при чтении и записи значения атрибута. Вот пример использования свойства для определения геттера и сеттера для атрибута `age` в классе `Person`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("Возраст не может быть отрицательным")
        self.__age = value

person = Person("Alice", 30)
print(person.age)  # выводит 30
person.age = 25
print(person.age)  # выводит 25
person.age = -10  # вызывает ValueError
```

В этом примере мы определили атрибут `_age` как "защищенный", а затем определили геттер и сеттер для него с помощью свойств `@property` и `@age.setter`. Геттер просто возвращает значение атрибута `_age`, а сеттер проверяет, что новое значение больше или равно нулю, прежде чем устанавливать его.

Обратите внимание, что при определении сеттера мы использовали декоратор `@age.setter`, который связывает сеттер с соответствующим геттером. Это позволяет использовать свойство `age` как обычный атрибут класса, но при этом вызывать методы, которые определены в геттере и сеттере.

С помощью геттеров и сеттеров можно обеспечить большую гибкость и контроль при работе с закрытыми атрибутами класса в Python. Однако следует помнить, что излишнее использование геттеров и сеттеров может привести к излишней сложности кода. Также, не следует использовать их слишком часто, а только там, где это необходимо для защиты и контроля данных.


## 2. Наследование
Наследование - это механизм ООП, который позволяет создавать новые классы на основе уже существующих классов. Новый класс, называемый подклассом, наследует атрибуты и методы своего родительского класса, называемого суперклассом. Подкласс может расширять или переопределять атрибуты и методы своего суперкласса, а также добавлять собственные атрибуты и методы.

В Python наследование реализуется с помощью ключевого слова `class`, за которым следует имя подкласса, а затем имя суперкласса, разделенные скобками. Вот пример определения подкласса `Child` на основе суперкласса `Person`:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hello(self):
        print(f"Hello, my name is {self.name} and I'm {self.age} years old.")

class Child(Person):
    def play(self):
        print(f"{self.name} is playing.")
```

В этом примере мы создали суперкласс `Person`, который имеет атрибуты `name` и `age`, а также метод `say_hello()`. Затем мы определили подкласс `Child`, который наследует атрибуты и метод `say_hello()` от суперкласса `Person`, а также добавляет свой собственный метод `play()`.

Теперь мы можем создать объекты обоих классов и использовать их методы:

```python
person = Person("Alice", 30)
person.say_hello()  # выводит "Hello, my name is Alice and I'm 30 years old."

child = Child("Bob", 5)
child.say_hello()  # выводит "Hello, my name is Bob and I'm 5 years old."
child.play()  # выводит "Bob is playing."
```

В этом примере мы создали объекты `person` и `child`, используя конструкторы `Person()` и `Child()`. Объект `person` имеет доступ к методу `say_hello()`, который определен в суперклассе `Person`. Объект `child` также имеет доступ к методу `say_hello()`, который он наследует от суперкласса `Person`, а также к методу `play()`, который определен в подклассе `Child`.

Ключевое слово `super` в Python используется для обращения к атрибутам и методам суперкласса из подкласса. Это позволяет избежать дублирования кода и обеспечивает более гибкое наследование.

Для использования `super` необходимо вызвать метод `super()` внутри метода подкласса и указать два аргумента: имя подкласса и объект self. Затем можно обращаться к методам и атрибутам суперкласса, используя синтаксис точечной нотации. Вот пример:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Employee(Person):
    def __init__(self, name, age, salary):
        super().__init__(name, age)
        self.salary = salary

employee = Employee("Alice", 30, 50000)
print(employee.name)  # выводит "Alice"
print(employee.age)  # выводит 30
print(employee.salary)  # выводит 50000
```

В этом примере мы создали класс `Person`, который имеет атрибуты `name` и `age`. Затем мы определили класс `Employee`, который наследует атрибуты и методы от класса `Person` и добавляет свой собственный атрибут `salary`. В методе `__init__()` подкласса `Employee` мы вызываем метод `__init__()` суперкласса `Person`, используя ключевое слово `super()`, чтобы инициализировать атрибуты `name` и `age`.


Если у родительских классов есть методы с одинаковыми именами, то при наследовании могут возникнуть проблемы. В зависимости от конкретного случая могут использоваться различные стратегии разрешения конфликтов:

1. Если методы имеют одинаковую сигнатуру (т.е. принимают одинаковые аргументы), то Python будет вызывать метод первого суперкласса в порядке, указанном в определении подкласса. Это называется методом разрешения конфликта "первый найденный" (MRO).

Вот пример:

```python
class A:
    def method(self):
        print("Method A")

class B:
    def method(self):
        print("Method B")

class C(A, B):
    pass

obj = C()
obj.method()  # выводит "Method A"
```

В этом примере класс `C` наследует метод `method()` от классов `A` и `B`. При вызове метода `method()` для объекта `obj` Python вызывает метод `method()` класса `A`, потому что `A` указан первым в определении подкласса `C`.

2. Если методы имеют разную сигнатуру, то Python не будет вызывать методы суперклассов, а вызовет метод, определенный в подклассе. Это называется переопределением метода.

Вот пример:

```python
class A:
    def method(self, x):
        print("Method A")

class B:
    def method(self, x, y):
        print("Method B")

class C(A, B):
    def method(self, x, y):
        print("Method C")

obj = C()
obj.method(1, 2)  # выводит "Method C"
```

В этом примере класс `C` определяет метод `method()`, который принимает два аргумента. Классы `A` и `B` также имеют методы `method()`, но с разной сигнатурой. При вызове метода `method()` для объекта `obj` будет вызван метод `method()` подкласса `C`.

3. Можно явно вызывать методы суперклассов с помощью функции `super()`. В этом случае методы будут вызываться в порядке, указанном в MRO.

Вот пример:

```python
class A:
    def method(self):
        print("Method A")

class B:
    def method(self):
        print("Method B")

class C(A, B):
    def method(self):
        super().method()  # вызывает метод A
        super(B, self).method()  # вызывает метод B

obj = C()
obj.method()  # выводит "Method A" и "Method B"
```

В этом примере метод `method()` подкласса `C` вызывает методы `method()` суперклассов `A` и `B` с пом


## 3. Полиморфизм

Полиморфизм - это способность объектов разных классов использовать одинаковый интерфейс, то есть методы с одинаковыми именами и сигнатурами, но с разной реализацией. В Python полиморфизм достигается за счет наследования и динамической типизации.


Для реализации полиморфизма в Python необходимо создать интерфейс в виде абстрактного класса или интерфейса с определенным набором методов. Классы, реализующие этот интерфейс, должны реализовать все методы интерфейса.

Абстрактный класс - это класс, который содержит один или несколько абстрактных методов, то есть методов без реализации. Абстрактный класс нельзя использовать для создания объектов, он используется только для наследования.


Вот пример интерфейса для классов фигур:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass
```

В этом примере мы создали абстрактный класс `Shape`, который содержит два абстрактных метода `area()` и `perimeter()`. Эти методы должны быть реализованы в подклассах `Shape`. Абстрактный класс создается с помощью декоратора `@abstractmethod` и метода `abstractmethod()` из модуля `abc`.

Теперь мы можем создать подклассы `Shape`, такие как `Circle`, `Rectangle` и `Triangle`, которые реализуют методы `area()` и `perimeter()`:

```python
import math

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

    def perimeter(self):
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def area(self):
        p = (self.a + self.b + self.c) / 2
        return math.sqrt(p * (p - self.a) * (p - self.b) * (p - self.c))

    def perimeter(self):
        return self.a + self.b + self.c
```

Каждый подкласс реализует методы `area()` и `perimeter()` по-своему, но они имеют одинаковые имена и сигнатуры, что позволяет нам использовать их вместе. Например, мы можем создать список фигур и вычислить их площади и периметры, используя методы из интерфейса `Shape`:

```python
shapes = [Circle(5), Rectangle(3, 4), Triangle(3, 4, 5)]
for shape in shapes:
    print("Area:", shape.area())
    print("Perimeter:", shape.perimeter())
```
Также в Python есть встроенные функции, которые используют полиморфизм. Например, функция `len()` может быть применена к объектам разных типов, таким как строки, списки и словари. В зависимости от типа объекта `len()` будет возвращать разную информацию.

```python
string = "Hello, world!"
print(len(string))  # выводит 13

lst = [1, 2, 3, 4, 5]
print(len(lst))  # выводит 5

dct = {'a': 1, 'b': 2, 'c': 3}
print(len(dct))  # выводит 3
```

В этом примере мы использовали функцию len() для объектов разных типов: строки, списка и словаря. Функция len() возвращает разную информацию в зависимости от типа объекта, но ее интерфейс (то есть имя и сигнатура) остается неизменным. Это позволяет нам использовать ее для объектов разных типов.

В Python существуют некоторые соглашения о том, как должен выглядеть интерфейс класса. Например, если класс реализует метод __len__(), то он должен возвращать длину объекта. Это позволяет использовать функцию len() для объектов разных типов.
